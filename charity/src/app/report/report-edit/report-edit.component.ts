import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { ReportService } from '../../services/report.service';
import { Report, ReportRequest, ReportType, ReportStatus } from '../../models/report.model';
import { KeycloakS } from '../../utils/keycloakService/keycloak-s';

@Component({
  selector: 'app-report-edit',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './report-edit.component.html',
  styleUrls: ['./report-edit.component.css']
})
export class ReportEditComponent implements OnInit {
  reportId: number = 0;
  report: Report | null = null;
  loading: boolean = false;
  loadingReport: boolean = false;
  error: string | null = null;
  successMessage: string | null = null;

  // Form model
  reportRequest: ReportRequest = {
    title: '',
    description: '',
    type: ReportType.GENERAL,
    periodStart: '',
    periodEnd: '',
    generatedBy: ''
  };

  // Enum values for template
  reportTypes = Object.values(ReportType);
  reportStatuses = Object.values(ReportStatus);

  // Min date for date inputs (today)
  minDate: string = '';

  constructor(
    private reportService: ReportService,
    private route: ActivatedRoute,
    private router: Router,
    private keycloakService: KeycloakS
  ) {
    // Set min date to today
    const today = new Date();
    this.minDate = today.toISOString().split('T')[0];
  }

  ngOnInit(): void {
    this.route.params.subscribe(params => {
      this.reportId = +params['id'];
      this.loadReport();
    });
  }

  loadReport(): void {
    this.loadingReport = true;
    this.error = null;

    this.reportService.getReportById(this.reportId).subscribe({
      next: (data) => {
        this.report = data;
        this.populateForm(data);
        this.loadingReport = false;
      },
      error: (err) => {
        this.error = 'Failed to load report. Please try again.';
        this.loadingReport = false;
        console.error('Error loading report:', err);
      }
    });
  }

  populateForm(report: Report): void {
    this.reportRequest = {
      title: report.title,
      description: report.description || '',
      type: report.type,
      periodStart: report.periodStart ? this.formatDateForInput(report.periodStart) : '',
      periodEnd: report.periodEnd ? this.formatDateForInput(report.periodEnd) : '',
      generatedBy: report.generatedBy
    };
  }

  formatDateForInput(dateString: string): string {
    // Convert ISO date to YYYY-MM-DD format for input[type="date"]
    const date = new Date(dateString);
    return date.toISOString().split('T')[0];
  }

  onSubmit(): void {
    if (this.validateForm()) {
      this.updateReport();
    }
  }

  validateForm(): boolean {
    this.error = null;

    if (!this.reportRequest.title.trim()) {
      this.error = 'Title is required';
      return false;
    }

    if (this.reportRequest.title.trim().length < 3) {
      this.error = 'Title must be at least 3 characters long';
      return false;
    }

    if (this.reportRequest.title.trim().length > 200) {
      this.error = 'Title must not exceed 200 characters';
      return false;
    }

    if (!this.reportRequest.generatedBy.trim()) {
      this.error = 'Generated By field is required';
      return false;
    }

    // Validate date range if both dates are provided
    if (this.reportRequest.periodStart && this.reportRequest.periodEnd) {
      const startDate = new Date(this.reportRequest.periodStart);
      const endDate = new Date(this.reportRequest.periodEnd);

      if (startDate > endDate) {
        this.error = 'Period Start date cannot be after Period End date';
        return false;
      }
    }

    return true;
  }

  updateReport(): void {
    this.loading = true;
    this.error = null;
    this.successMessage = null;

    // Convert dates to ISO format if provided
    const request: ReportRequest = {
      ...this.reportRequest,
      periodStart: this.reportRequest.periodStart
        ? new Date(this.reportRequest.periodStart).toISOString()
        : undefined,
      periodEnd: this.reportRequest.periodEnd
        ? new Date(this.reportRequest.periodEnd).toISOString()
        : undefined
    };

    this.reportService.updateReport(this.reportId, request).subscribe({
      next: (response) => {
        this.loading = false;
        this.successMessage = 'Report updated successfully!';

        // Navigate back to detail page after 1.5 seconds
        setTimeout(() => {
          this.router.navigate(['/reports', this.reportId]);
        }, 1500);
      },
      error: (err) => {
        this.loading = false;
        this.error = 'Failed to update report. Please try again.';
        console.error('Error updating report:', err);
      }
    });
  }

  cancel(): void {
    if (confirm('Are you sure you want to cancel? Any unsaved changes will be lost.')) {
      this.router.navigate(['/reports', this.reportId]);
    }
  }

  backToList(): void {
    this.router.navigate(['/reports']);
  }

  clearDates(): void {
    this.reportRequest.periodStart = '';
    this.reportRequest.periodEnd = '';
  }

  getTypeDisplayName(type: ReportType): string {
    return type.replace('_', ' ');
  }

  formatDate(dateString: string): string {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  getStatusClass(status: ReportStatus): string {
    switch (status) {
      case ReportStatus.COMPLETED:
        return 'status-completed';
      case ReportStatus.IN_PROGRESS:
        return 'status-in-progress';
      case ReportStatus.PENDING:
        return 'status-pending';
      case ReportStatus.FAILED:
        return 'status-failed';
      case ReportStatus.CANCELLED:
        return 'status-cancelled';
      default:
        return '';
    }
  }
}
